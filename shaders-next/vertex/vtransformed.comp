#version 460 core
#extension GL_GOOGLE_include_directive : enable


#define VERTEX_FILLING
//#define USE_PUSH_CONSTANT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/vertex.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex-input.glsl"

LOCAL_SIZE_LAYOUT;

// attribute formating
const int NORMAL_TID = 0;
const int TEXCOORD_TID = 1;
const int TANGENT_TID = 2;
const int BITANGENT_TID = 3;
const int VCOLOR_TID = 4;
const int VCOUNT = 3;

struct Transforms { mat4 transform, transformNrm; };
layout ( binding = 0, set = 2, std430 ) readonly buffer VTE_TRANSFORMS { Transforms vTransforms[]; };

#define wsize vertexBlock.primitiveCount

void main() {
    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);

    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=gl_NumWorkGroups.x) {
        SB_BARRIER
        const uint globalID = (w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        IFALL (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {

            // constant material ID from vertex instance
            const uint rofft = uint(vertexBlock.readOffset) + globalID, wofft = uint(vertexBlock.primitiveOffset) + globalID;

            // read material accessor
            uint matID = 0u;
            readByAccessorIndice(vertexBlock.materialAccessor, rofft, matID);
            matID += uint(vertexBlock.materialID);

            // planned to support quad based geometry
            vmaterials[wofft] = int(matID);
            vbitfields[wofft] = vertexBlock.bitfield;

            // 
            const uint inputID = gl_GlobalInvocationID.y + uint(cblock.inputID);

            // load attrib data
            [[unroll]]
            for (uint a=vertexBlock.attributeOffset;a<min(min(ATTRIB_EXTENT, attributes.length()), vertexBlock.attributeCount)+vertexBlock.attributeOffset;a++) {
                [[unroll]]
                for (int i=0;i<3;i++) {
                    vec4 attribValue = vec4(0.f); uint indiceID = rofft * VCOUNT + i;
                    readByAccessorIndice(vertexBlock.indiceAccessor, indiceID, indiceID);
                    readByAccessor(attributes[a].accessorID, indiceID, attribValue);
                    if (a == NORMAL_TID) { attribValue = mult4(vTransforms[inputID].transformNrm, attribValue); }
                    storeAttribute(ivec3(wofft, attributes[a].attributeID, i), attribValue);
                }
            }

            // load vertex data
            [[unroll]]
            for (int i=0;i<3;i++) {
                vec4 vertice = vec4(0.f, 0.f, 0.f, 1.f); uint indiceID = rofft * VCOUNT + i;
                readByAccessorIndice(vertexBlock.indiceAccessor, indiceID, indiceID);
                readByAccessor(vertexBlock.verticeAccessor, indiceID, vertice);
                storePosition(ivec2(wofft, i), mult4(vTransforms[inputID].transform, vec4(vertice.xyz, 1.f)));
            }
            
        }
    }
}
