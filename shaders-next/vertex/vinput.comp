#version 460 core
#extension GL_GOOGLE_include_directive : enable


#define VERTEX_FILLING
#define USE_PUSH_CONSTANT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/vertex.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex-input.glsl"

LOCAL_SIZE_LAYOUT;

initAtomicSubgroupIncFunctionDyn(tcounter[0], tcounterInc, int)

void main(){
    const int wsize = int(vertexBlock.primitiveCount);
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups.x);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;
    const int trp = 3;

    // for faster geometry loading, just add counter in single thread
    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) { atomicAdd(tcounter[0], wsize); }
    
    // process vertex assembly
    for (int w=0;w<wsize;w+=rng) {
        int globalID = w + wID * gS + lID;
        IFALL (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {

            // constant material ID from vertex instance 
            int matID = int(vertexBlock.materialID);
            int ordr = tcounter[1] + int(globalID), tidc = ordr;//, tidc = tcounterInc(1);

            // planned to support quad based geometry
            vorders[tidc] = ordr;
            materials[tidc] = matID;
            
            // planned to add support of vertex and geometry shaders
            [[unroll]]
            for (int i=0;i<3;i++) {
                // aggregated indices
                uint indiceID = (vertexBlock.primitiveOffset + globalID) * trp + i;
                readByAccessorIndice(int(vertexBlock.indiceAccessor), indiceID, indiceID);

                // load attrib data
                [[unroll]]
                for (uint a=0;a<min(min(ATTRIB_EXTENT, attributes.length()), vertexBlock.attributeCount);a++) {{
                    uint a = attributes[a].attributeID;
                    vec4 attribValue = vec4(0.f); readByAccessor(attributes[a].accessorID, indiceID, attribValue);
                    ivec2 ATTRIB_ = gatherMosaic(getUniformCoord(int(tidc*ATTRIB_EXTENT+a)));
                    ISTORE(attrib_texture_out, mosaicIdc(ATTRIB_, i), floatBitsToUint(attribValue));
                }}

                // load vertex data
                {
                    vec4 vertice = vec4(0.f, 0.f, 0.f, 1.f); readByAccessor(int(vertexBlock.verticeAccessor), indiceID, vertice);
                    imageStore(lvtx, tidc*3+i, vec4(vertice.xyz, 1.f));
                }
            }
            
        }
    }
}
