#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define DISCARD_SHARED_CACHING
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
//#define CACHE_HIT_PAYLOAD
//#define DMA_HIT // unpreferred

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"
#include "./submodules/environment.glsl"

#define cray rays[rayID]

#ifdef CACHE_HIT_PAYLOAD
shared VtHitPayload hitPayloadCache[WORK_SIZE];
#define hitp hitPayloadCache[Local_Idx]
#else
VtHitPayload hitp;
#endif


LOCAL_SIZE_LAYOUT;

void main() {
    int wsize = int(missHitCounter);
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    int rayID = -1;
    
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool overflow = overflow || globalID >= wsize || globalID < 0;
        int hitID = overflow ? -1 : vtMissId(globalID);

        IFALL(overflow) break;
        {
#ifdef DMA_HIT
            #define hit hits[hitID]
#else
            VtHitData hit = hits[hitID];
#endif

            rayID = hit.rayID-1;
            hitp = hitPayload[hit.payloadID-1];

            vec3 viewVec = dcts(cray.cdirect.xy);
            vec3 rorigin = cray.origin.xyz;
            globalInvocationSMP = globalID;

            int matID = -1;
            bool overflow = overflow || rayID < 0;

            // environment
            hitp.specularGlossiness = vec4(0.f.xxx, 1.f);
            hitp.albedo = vec4(0.f.xxx, 1.f);
            EnvironmentShader(hitp.emission, cray);
            
            // ray direction debug emission
            //hitp.emission = vec4(viewVec*0.5f+0.5f, 1.f);
            hitp.emission = vec4(vec3(0.05f, 0.05f, 0.2f), 1.f);

            // additional validation of hit (hit point interpolated offset test)
            if (!overflow && hitID >= 0) {
                int pid = hit.payloadID-1;
                if (pid < 0) pid = hitID;//atomicIncPayloadHitCount();
                hitPayload[pid] = hitp;

                // make payload ID
                if (hit.payloadID <= 0) {
                    hit.payloadID = pid+1;
#ifndef DMA_HIT
                    hits[hitID] = hit;
#endif
                }
            }
        }
    }
}
