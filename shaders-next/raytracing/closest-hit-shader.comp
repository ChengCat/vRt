#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define DISCARD_SHARED_CACHING
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
//#define CACHE_HIT_PAYLOAD
//#define DMA_HIT // unpreferred

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"

// attribute formating
const int NORMAL_TID = 0;
const int TEXCOORD_TID = 1;
const int TANGENT_TID = 2;
const int BITANGENT_TID = 3;
const int VCOLOR_TID = 4;

struct VtAppMaterial {
     vec4 diffuse;
     vec4 specular;
     vec4 transmission;
     vec4 emissive;

     float ior;
     float roughness;
     float alpharef;
     float unk0f;

     uint diffuseTexture;
     uint specularTexture;
     uint bumpTexture;
     uint emissiveTexture;

     int flags;
     int alphafunc;
     int binding;
     int bitfield;
};

#include "../include/hit-lib.glsl"

// texturing cache 
struct Textured {
    vec4 diffuse;
    vec4 specular;
    vec4 bump;
    vec4 emissive;
} textured;

#define cray rays[rayID]

LOCAL_SIZE_LAYOUT;

#ifdef CACHE_HIT_PAYLOAD
shared VtHitPayload hitPayloadCache[WORK_SIZE];
#define hitp hitPayloadCache[Local_Idx]
#else
VtHitPayload hitp;
#endif



layout (binding = 0, set = 2, std430) readonly buffer VT_GEN_EXAMPLE {
    mat4x4 camInv;
    mat4x4 projInv;
    vec4 sceneRes;
    int enable360, variant, r1, r2;
} cameraUniform;

void main() {

    // constants
    const float IOR = 1.400f;
    const float diffuse_min_importance = 0.5f;
    const float reflect_min_importance = 0.5f;
    const vec3 max_fresnel_color = toLinear(vec3(1.f));
    const vec3 min_fresnel_color = toLinear(vec3(1.f));

    int wsize = int(closestHitCounter);
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    int rayID = -1;
    
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool overflow = overflow || globalID >= wsize || globalID < 0;
        int hitID = overflow ? -1 : vtClosestId(globalID);
        IFALL(overflow) break;
        {
#ifdef DMA_HIT
            #define hit hits[hitID]
#else
            VtHitData hit = hits[hitID];
#endif

            rayID = hit.rayID-1;
            hitp = hitPayload[hit.payloadID-1];

            vec3 viewVec = dcts(cray.cdirect.xy);
            vec3 rorigin = cray.origin.xyz;
            globalInvocationSMP = globalID;

            matID = hit.materialID;// - materialOffset;
            //bool overflow = overflow || rayID < 0 || (matID >= materialCount || matID < 0);
            bool overflow = overflow || rayID < 0;

            // static colors
            textured.diffuse = material.diffuse;
            textured.bump = vec4(0.f, 0.f, 1.f, 1.f);
            textured.specular = material.specular;
            textured.emissive = material.emissive;

            // AMD not supported per-lane texture data loading, if texture index is not constant
            vec2 texcoord = imageLoad(attributes, makeAttribID(hit.attribID, TEXCOORD_TID)).xy; //hit.attributes[TEXCOORD_TID].xy; //hit.texcoord.xy;
            vec3 normal = imageLoad(attributes, makeAttribID(hit.attribID, NORMAL_TID)).xyz; //hit.attributes[NORMAL_TID].xyz;
            vec3 bitang = imageLoad(attributes, makeAttribID(hit.attribID, BITANGENT_TID)).xyz; //hit.attributes[BITANGENT_TID].xyz;
            vec3 tangent = imageLoad(attributes, makeAttribID(hit.attribID, TANGENT_TID)).xyz; //hit.attributes[TANGENT_TID].xyz;

            // use HW intersected normal if something wrong
            normal.xyz = length(hitp.normalHeight.xyz) <= 1e-5 ? hit.vdat.xyz : normal.xyz;

            mat3 tbn = transpose(mat3(tangent.xyz, bitang.xyz, normal.xyz));
            vec3 pV = normalize(tbn * (-viewVec * hit.uvt.z));
            float hW = 0.f;

#ifndef PLAIN_BINDLESS_TEXTURE_FETCH
            bool wasTextured = false;
            [[unroll]]
            for (int wl=0;wl<Wave_Size_RT;wl++) {
                IFALL(wasTextured) break;
                if (!wasTextured && readLane(hit.materialID, wl) == hit.materialID) { // don't occupy warpy
                    wasTextured = true;
#endif
#ifdef ENABLE_POM
                    SB_BARRIER
                    texcoord = parallaxMapping(pV, texcoord, hW);
#endif
                    SB_BARRIER
                    textured.bump.xyz = getNormalMapping(texcoord);
                    SB_BARRIER
                    textured.diffuse = fetchDiffuse(texcoord);
                    SB_BARRIER
                    textured.specular = fetchSpecular(texcoord);
                    SB_BARRIER
                    textured.emissive = fetchEmission(texcoord);
                    SB_BARRIER
#ifndef PLAIN_BINDLESS_TEXTURE_FETCH
                }
            }
#endif

            vec4 diffuse = textured.diffuse; diffuse.xyz = toLinear(max(diffuse.xyz, vec3(0.f)));
            vec4 emission = textured.emissive; emission.xyz = toLinear(max(emission.xyz, vec3(0.f)));
            vec4 spc = clamp01(textured.specular);

            // default normal
            hitp.normalHeight.xyz = normal.xyz;

            
            if (validateTexture(material.bumpTexture)) { // block TBN change manually if non valid normal mapped texture
                hitp.normalHeight.xyz = textured.bump.xyz * tbn; // apply TBN with normal mapping
            }

            // if normal goes wrong, restore normal
            if ((length(hitp.normalHeight.xyz) <= 1e-5) || (length(hitp.normalHeight.xyz) >= INFINITY) || any(isnan(hitp.normalHeight.xyz)) || any(isinf(hitp.normalHeight.xyz)) || dot(hitp.normalHeight.xyz, normal.xyz) <= 1e-5) {
                hitp.normalHeight.xyz = normal.xyz;
            }

            // convert metallic roughness to glossiness specular PBR model
            normal.xyz = faceforward(normal.xyz, dcts(cray.cdirect.xy), normal.xyz);
            float roughness = clamp01(spc.y), metallic = clamp01(spc.z);
            float fresnel = clamp01(pow(abs(dot(dcts(cray.cdirect.xy), normal.xyz)), IOR - 1.f));

            vec3 fresnelColor = clamp01(fmix(max_fresnel_color * 0.9f, min_fresnel_color * 0.04f, fresnel.xxx));
            vec3 specularColor = clamp01(mix(fresnelColor, diffuse.xyz, metallic.xxx)); // use correct specular
            diffuse.xyz *= (1.f - metallic); // dim diffuse by metallic
            vec4 specularGlossiness = vec4(specularColor, roughness);

            // normalize normal again
            hitp.normalHeight.xyz = normalize(hitp.normalHeight.xyz);
            hitp.emission = emission.xyzw;
            hitp.albedo = diffuse.xyzw;
            hitp.specularGlossiness = specularGlossiness;

            // triangle intersection test
            IFANY (cameraUniform.variant == 1) {
                hitp.emission = vec4(vec3(0.5f, 0.5f, 1.0f), 1.f);
                //hitp.emission = vec4(hitp.normalHeight.xyz * 0.5f + 0.5f, 1.f);
            } else {
                hitp.emission = vec4(imageLoad(attributes, makeAttribID(hit.attribID, VCOLOR_TID)).xyz, 1.f);
            }

            // additional validation of hit (hit point interpolated offset test)
            if (!overflow && hitID >= 0) {
                int pid = hit.payloadID-1;
                if (pid < 0) pid = hitID;//atomicIncPayloadHitCount();
                hitPayload[pid] = hitp;

                // make payload ID
                if (hit.payloadID <= 0) {
                    hit.payloadID = pid+1;
#ifndef DMA_HIT
                    hits[hitID] = hit;
#endif
                }
            }
        }
    }
}
