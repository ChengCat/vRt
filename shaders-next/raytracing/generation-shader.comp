#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"

// use partition by 8x8
layout (local_size_x = R_BLOCK_WIDTH, local_size_y = R_BLOCK_HEIGHT) in;

layout (binding = 0, set = 2) readonly buffer VT_GEN_EXAMPLE {
    mat4x4 camInv;
    mat4x4 projInv;
    vec4 sceneRes;
    int enable360, r0, r1, r2;
} cameraUniform;

// planned ray generation shader example
void main() {
    VtRay ray;
    ray.origin.w = uintBitsToFloat(bitfieldInsert(Global_Idx.x & 0xFFFFu, Global_Idx.y, 16, 16)); // save hashed2D (max to 65535x65535)
    
    ivec2 wh = ivec2(cameraUniform.sceneRes.xy);
    ivec2 xy = ivec2(Global_Idx.xy);
    vec2 sceneResInv = 1.0f / vec2(wh);
    vec2 rnd = vec2(0.5f);
    vec2 coord = (floor(vec2(xy)) + clamp(rnd, vec2(0.0001f), vec2(0.9999f))) * sceneResInv;

    vec4 dir = vec4(0.f), orig = mult4(cameraUniform.camInv, vec4(vec3(0.0f), 1.0f)), eye = orig;
    IFANY (cameraUniform.enable360 == 1) {
        vec2 pic = (coord * vec2(2.f,1.f) + vec2(0.5f,0.0f)) * PI;
        dir = mult4(cameraUniform.camInv, vec4(dcts(pic), 0.f));
    } else {
        vec4 co = divW(mult4(cameraUniform.camInv, mult4(cameraUniform.projInv, vec4(coord * 2.0f - 1.0f, 0.999f, 1.0f))));
        orig = divW(mult4(cameraUniform.camInv, mult4(cameraUniform.projInv, vec4(coord * 2.0f - 1.0f, 0.001f, 1.0f))));
        dir = vec4(normalize(co.xyz - orig.xyz)*vec3(1.f,1.f,1.f), 0.0f);
    }

    ray.dcolor = uvec2(0u.xx);
    WriteColor(ray.dcolor, vec4(0.f));
    RayActived(ray, true_);
    ray.origin.xyz = orig.xyz;
    ray.cdirect = lcts(dir.xyz);
    vtEmitRays(ray);


    /*
    int wsize = RAY_BLOCK samplerUniform.blockCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(Wave_Size_RT);
    int wcount = min(tiled(wsize, wcsize), 1000000);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);

    LGROUP_BARRIER;
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(Wave_Idx);
        globalInvocationSMP = globalID;

        // check if not reached blocks limit
        bool overflow = overflow || globalID >= wsize;
        IFALL(overflow) break;
        IFANY(!overflow) {
            
            // accquire shading block
            currentBlock = -1;
            if (!overflow) accquireBlock(globalID);
            bool invld = anyInvoc(overflow || currentBlock < 0 || currentBlockSize <= 0);
            if (invld) { currentBlock = -1; continue; }
            
            // invoke block data
            if (!invld) {
                uint bts = min(R_BLOCK_SIZE, currentBlockSize);
                for (int tb = 0; tb < bts; tb += int(Wave_Size_RT)) {
                    SB_BARRIER
                    int nid = tb + int(Lane_Idx);
                    randomClocks = 0, subHash = nid; // reset random clocks
                    bool overflow = invld || overflow || nid >= bts || nid < 0;
                    IFALL(overflow) break;
                    accquireNode(nid); overflow = overflow || currentBlockNode < 0;
                    IFALL(overflow) break;

                    // make unordered lists for context
                    if (!overflow && SSC(RayActived(currentRay))) {
                        uint uidx = atomicIncTT();
                        unorderedRays[uidx].cdirect = currentRay.cdirect;
                        unorderedRays[uidx].origin = currentRay.origin;
                        unorderedRays[uidx].dcolor.x = getGeneralNodeId()+1;
                        unorderedRays[uidx].dcolor.y = 0;
                    }
                }
            }

        }
    }*/

    LGROUP_BARRIER;
}
