#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define WORK_SIZE_BND 1024
#define BVH_CREATION

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./submodules/includes.glsl"

// optimize by shareds
//shared mat4 _lrbox[WORK_SIZE_BND];
//#define lrbox _lrbox[Local_Idx]
//shared ivec4 _comp[WORK_SIZE_BND]; 
//#define comp _comp[Local_Idx]

void unifyNodeBox(inout int idx){
    // initial for unify box
    ivec2 comp = imageLoad(bvhMeta, idx).xy-1; // meta of contributable
    if (comp.x != comp.y && comp.x >= 0) {

        // get contributors boxes
        mat4 lrbox = mat4(bvhBoxesWork[comp.x][0], bvhBoxesWork[comp.y][0], bvhBoxesWork[comp.x][1], bvhBoxesWork[comp.y][1]);

        // contribute to current node
        bvhBoxesWork[idx] = vec4[2](min(lrbox[0], lrbox[1]), max(lrbox[2], lrbox[3]));

        // transpose and compress boxes of contributors
        lrbox = transpose(lrbox);

        // transposed save
#ifdef USE_F32_BVH
        bvhBoxesResulting[comp.x >> 1] = fvec4_[4](fvec4_(lrbox[0]), fvec4_(lrbox[1]), fvec4_(lrbox[2]), fvec4_(lrbox[3]));
#else
        bvhBoxesResulting[comp.x >> 1] = uvec2[4](packHalf4x16(lrbox[0]), packHalf4x16(lrbox[1]), packHalf4x16(lrbox[2]), packHalf4x16(lrbox[3]));
#endif
    }
}

layout ( local_size_x = WORK_SIZE_BND ) in;

#define lID Local_Idx
#define gS gl_WorkGroupSize.x
#define wsize bvhBlock.leafCount

void main() {
    // move to work list
    const uint rng = gS*gl_NumWorkGroups.x;
    [[unroll, dependency_length(4)]]
    for (uint w=gS*gl_WorkGroupID.x;w<wsize;w+=rng) {
        SB_BARRIER
        const uint globalID = (w + lID);
        IFALL (globalID >= wsize) break; // add to queue list parent node
        int idx = globalID < wsize ? LeafIndices[globalID]-1 : -1;

        [[dependency_infinite]]
        for (int l=0;l<65536;l++) {
            const int pid = idx >= 0 ? (imageLoad(bvhMeta, idx).z-1) : -1;
            idx = pid >= 0 && atomicCompSwap(Flags[pid], 0, 1) == 1 ? pid : -1;
            if ( idx >= 0 ) { unifyNodeBox(idx); Flags[idx] = 0; } else { break; };
        }
    }
    LGROUP_BARRIER
}
