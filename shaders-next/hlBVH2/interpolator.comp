#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define ENABLE_VERTEX_INTERPOLATOR
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define ENABLE_VSTORAGE_DATA
#define DMA_HIT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/structs.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"

LOCAL_SIZE_LAYOUT;

#define wsize closestHitCounterCurrent

void main() {
    // accumulate closest hits
    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) { add(closestHitCounter, closestHitCounterCurrent); }
    SB_BARRIER

    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);
    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=gl_NumWorkGroups.x) {
        SB_BARRIER
        int globalID = int((w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x);
        bool overflow = globalID >= wsize; IFALL(overflow) break;
        int hitID = overflow ? -1 : vtClosestId(stageUniform.closestHitOffset + globalID);
        
#ifdef DMA_HIT
        #define hit hits[hitID]
#else
        VtHitData hit = hits[hitID];
#endif

        if (!overflow) { // verify intersection
            const int triID = floatBitsToInt(hit.uvt.w)-1, rID = parameteri(VTX_TYPE, uint(vbitfields[triID]));

            // interpolate hit
            if (triID >= 0) {
                const int itri = triID*3; const vec3 v0 = TLOAD(lvtxIn, itri+0).xyz;
                hit.uvt.w = intBitsToFloat(vmaterials[triID]);
                hit.vdat = vec4(normalize(cross(TLOAD(lvtxIn, itri+1).xyz-v0, TLOAD(lvtxIn, itri+2).xyz-v0)), uintBitsToFloat(rID));
                interpolateMeshData(hit, triID);
#ifndef DMA_HIT
                hits[hitID] = hit;
#endif
            }

            [[unroll]]
            for (int i=0;i<4;i++) {
                [[flatten]]
                if (rID == i) { vtVerifyClosestHit(hitID, i); break; }
            }
        }
    }

    LGROUP_BARRIER;
}
