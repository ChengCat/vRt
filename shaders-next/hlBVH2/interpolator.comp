#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define ENABLE_VERTEX_INTERPOLATOR
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define ENABLE_VSTORAGE_DATA

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/structs.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"

LOCAL_SIZE_LAYOUT;

void main() {
    // accumulate closest hits
    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) { 
        atomicAdd(closestHitCounter, closestHitCounterCurrent); 
    }
    
    int wsize = int(closestHitCounterCurrent);
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    int wgs = int(gl_NumWorkGroups);

    LGROUP_BARRIER;
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool_ overflow = bool_(globalID >= wsize);
        IFALL(overflow) break;
        int hitID = SSC(overflow) ? -1 : vtClosestId(globalID);
        
        VtHitData hit = hits[hitID];
        IF (not(overflow)) { // verify intersection
            const int triID = floatBitsToInt(hit.uvt.w)-1;
            const int itri = triID*3;//tri*9;
            const mat3 vT = transpose(mat3(
                TLOAD(lvtx, itri+0).xyz,
                TLOAD(lvtx, itri+1).xyz,
                TLOAD(lvtx, itri+2).xyz
            ));
            const vec3 vs = vec3(1.0f - hit.uvt.x - hit.uvt.y, hit.uvt.xy);
            const vec3 hitOrigin = vs * vT;

            // interpolate hit
            IF (lessF(hit.uvt.z, INFINITY-0.001f) & bool_(triID >= 0)) {
                const vec3 e1 = vT[1]-vT[0], e2 = vT[2]-vT[0];
                hit.vdat = vec4(normalize(cross(e1, e2)), 1.f);
                interpolateMeshData(hit, vs);
                hits[hitID] = hit;
            }
        }
    }

    LGROUP_BARRIER;
}
