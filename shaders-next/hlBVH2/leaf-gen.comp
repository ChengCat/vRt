#version 460 core
#extension GL_GOOGLE_include_directive : enable

//#define VTX_TRANSPLIT
#define ENABLE_VSTORAGE_DATA
#define BVH_CREATION
#define LEAF_GEN

#include "../include/driver.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/structs.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "./submodules/includes.glsl"

//initAtomicSubgroupIncFunction(nCounter, atomicIncLeaf, 1, int)

LOCAL_SIZE_LAYOUT;

void main() {
    //const int wsize =  bvhBlock.primitiveCount;
    //const int gS = int(gl_WorkGroupSize.x);
    //const int wgs = int(gl_NumWorkGroups.x);
    //const int wID = int(gl_WorkGroupID.x);
    //const int lID = int(Local_Idx);
#define wsize bvhBlock.primitiveCount
#define gS gl_WorkGroupSize.x
#define wgs gl_NumWorkGroups.x
#define wID gl_WorkGroupID.x
#define lID Local_Idx

    const uint rng = gS*wgs;
    for (uint w=0;w<wsize;w+=rng) {
        SB_BARRIER
        const uint globalID = w + (wID * gS + lID);
        IFALL (globalID >= wsize) break;

        const uint tri = bvhBlock.primitiveOffset+clamp(globalID, 0, bvhBlock.primitiveCount-1); int itri = int(tri*3);
        const mat3x4 triverts = mat3x4(
            divW(mult4(bvhBlock.transform, vec4(TLOAD(lvtxIn, itri+0).xyz, 1.f))),
            divW(mult4(bvhBlock.transform, vec4(TLOAD(lvtxIn, itri+1).xyz, 1.f))),
            divW(mult4(bvhBlock.transform, vec4(TLOAD(lvtxIn, itri+2).xyz, 1.f)))
        );

// (+) death mark 
// TODO: separate input and outputs

#ifdef VTX_TRANSPLIT
        // transpose VTX
        mat3x3 vtxL = transpose(mat3(
            TLOAD(lvtxIn, itri+0).xyz,
            TLOAD(lvtxIn, itri+1).xyz,
            TLOAD(lvtxIn, itri+2).xyz
        ));

        { // transpose type
            imageStore(lvtx, itri+0, vec4(vtxL[0].xyz, 1.f));
            imageStore(lvtx, itri+1, vec4(vtxL[1].xyz, 1.f));
            imageStore(lvtx, itri+2, vec4(vtxL[2].xyz, 1.f));
        }
#endif

        // view based 
        vec4 bcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;

        // gen morton code
        uvec2 mortonCode = 
#if defined(INTEL_PLATFORM)
        encodeMorton3_64(clamp(uvec3(floor(fma(bcenter.xyz, 0.5f.xxx, 0.5f.xxx)*1024.0f)), uvec3(0), uvec3(0x3FF)));
#else
        encodeMorton3_64(clamp(uvec3(floor(fma(bcenter.xyz, 0.5f.xxx, 0.5f.xxx)*2097152.0f)), uvec3(0), uvec3(0x1FFFFF)));
#endif

#define to globalID

        // gen leaf
        HlbvhNode outLeaf = Leafs[to];
        outLeaf.lbox = calcTriBox(triverts);
        outLeaf.pdata.xy = ivec2(to);
        outLeaf.pdata.zw = ivec2(0, tri+1);

        // store leaf data
        [[flatten]]
        if (globalID < wsize && globalID >= 0) {
            Leafs[to] = outLeaf;
            Mortoncodes[to] = mortonCode;
            MortoncodesIndices[to] = int(to+1);
        }
    }

    LGROUP_BARRIER
}