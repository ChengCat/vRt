#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define VRT_USE_FAST_INTERSECTION
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING
#define ENABLE_TRAVERSE_DATA
#define ENABLE_VSTORAGE_DATA
#define DMA_HIT

#define EXTEND_LOCAL_GROUPS

#include "../include/driver.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/morton.glsl"
#include "../include/vertex.glsl"

#include "./submodules/traverse-bvh2.glsl"

//#define wsize rayCounter
#define wgs gl_NumWorkGroups.x

LOCAL_SIZE_LAYOUT;

//int RTP(in uint groupID) { return groupID < 4 ? rayTypedCounterRead[groupID] : 0; };
void main() {
    //uint wsize = uint(subgroupAdd(RTP(Lane_Idx))); // use subgroup for fast getting of all groups count
    uint wsize = min(rayCounter, MAX_RAYS); IFALL (wsize <= 0) return;

    uint wcount = min(tiled(wsize, gl_WorkGroupSize.x), 1000000u);
    traverseState.cacheID = int(gl_GlobalInvocationID.x), traverseState.minDist = 0.f;
     
    for (uint w=0;w<wcount;w+=wgs) {
         int it = int((w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x);
         bool overflow = it >= wsize; IFALL(overflow) break;

        // do BVH traversing 
         int rayID = vtRayIdx(it); int hid = vtFetchHitIdc(rayID);
        primitiveState.lastIntersection = vec4(0.f.xx, INFINITY, FINT_ZERO);
         if (!overflow) traverseBvh2(!overflow, hid, rays[rayID].origin.xyz, rays[rayID].cdirect.xy);

        // planned multiple-hits support
         if (!overflow) { // verify intersection
             int triID = floatBitsToInt(primitiveState.lastIntersection.w)-1;
             bool found = triID >= 0;
             if (hid < 0) hid = atomicIncHitCount(); // reserve one hit

#ifdef DMA_HIT
            #define hit hits[hid]
#else
            VtHitData hit;
#endif
            hit.payloadID = 0, hit.rayID = rayID+1;

            // if found as minimum one intersection
            if (found) {
                 if (hid < 0) hid = atomicIncHitCount(); // if required new
                hit.uvt = primitiveState.lastIntersection;
                hit.attribID = vtVerifyClosestHit(hid,-1)+1;
                //imageAtomicMax(rayLink,rayID<<1, (hid+1).x);
            }
            
            // if no found any intersection
            // planned to add multi-traversing support, and another resolver
            if (!found) {
                 if (hid < 0) hid = atomicIncHitCount(); // if required new
                hit.uvt = vec4(0.f.xx, INFINITY, intBitsToFloat(-1));
                hit.attribID = 0; vtVerifyMissedHit(hid, 0);
                //imageAtomicMax(rayLink,rayID<<1, (hid+1).x);
            }

#ifndef DMA_HIT
            hits[hid] = hit;
#endif
        }
    }

    //LGROUP_BARRIER;
}
