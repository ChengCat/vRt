#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define USE_FAST_INTERSECTION
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING
#define ENABLE_TRAVERSE_DATA
#define ENABLE_VSTORAGE_DATA
#define DMA_HIT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/structs.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"

//#define USE_STACKLESS_BVH
#include "./submodules/traverse-bvh2.glsl"

LOCAL_SIZE_LAYOUT;

void main() {
    int wsize = rayCounter;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    int wgs = int(gl_NumWorkGroups);
    cacheID = int(gl_GlobalInvocationID.x);

    LGROUP_BARRIER;
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool_ overflow = bool_(it >= wsize);
        IFALL(overflow) break;

        // do BVH traversing 
        currentRayTmp = rays[it]; // fix SPIR-V error
        int hid = vtFetchHitIdc(it);
        traverseBvh2(not(overflow), hid);

        IF (not(overflow)) { // verify intersection
            const int triID = floatBitsToInt(geometrySpace.lastIntersection.w)-1;
            if (hid < 0) hid = it;

#ifdef DMA_HIT
            #define hit hits[hid]
#else
            VtHitData hit;
#endif

            hit.rayID = it+1;
            hit.uvt = geometrySpace.lastIntersection;
            hit.payloadID = 0;
            hit.materialID = materials[triID];
            hit.next = 0;
            hit.attribID = 0;

            // identify intersection
            imageStore(rayLink, it, uvec4(hid+1, imageLoad(rayLink, it).y, 0u.xx));
            IF (triID >= 0) {
                //atomicIncAttribCount()+1;
                hit.attribID = vtVerifyClosestHit(hid)+1; // better link directly, because extra atomics (even with subgroups) also hits to performances
            } else {
                //vtVerifyMissedHit(hid); 

                const int rID = RayType(rays[hit.rayID-1]);
                [[unroll]]
                for (int i=0;i<4;i++) {
                    [[flatten]]
                    if (rID == i) vtVerifyMissedHit(hid, i);
                }
            }

#ifndef DMA_HIT
            hits[hid] = hit;
#endif
        }
    }

    LGROUP_BARRIER;
}
