#version 460 core
#extension GL_GOOGLE_include_directive : enable

//#define VTX_TRANSPLIT
#define ENABLE_VSTORAGE_DATA
#define BVH_CREATION
#define LEAF_GEN

#ifndef INTEL_PLATFORM
#define PREFER_64BIT_MORTON_TYPE
#endif

#include "../../include/driver.glsl"
#include "../../include/mathlib.glsl"
#include "../../include/ballotlib.glsl"
#include "../../include/structs.glsl"
#include "../../include/vertex.glsl"
#include "../../include/morton.glsl"
#include "../submodules/includes.glsl"

LOCAL_SIZE_LAYOUT;

#define wsize bvhBlock.primitiveCount

void main() {
    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);
    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=gl_NumWorkGroups.x) {
        SB_BARRIER
        const uint globalID = (w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        IFALL (globalID >= wsize) break;

        const uint tri = bvhBlock.primitiveOffset+clamp(globalID, 0, bvhBlock.primitiveCount-1); const int itri = int(tri*3);
        const mat3x4 trivertsUnit = mat3x4(
            divW(mult4(bvhBlock.transform, TLOAD(lvtxIn, itri+0).xyzw)),
            divW(mult4(bvhBlock.transform, TLOAD(lvtxIn, itri+1).xyzw)),
            divW(mult4(bvhBlock.transform, TLOAD(lvtxIn, itri+2).xyzw))
        );
        //const mat3x4 triverts = mat3x4(TLOAD(lvtxIn, itri+0).xyzw,TLOAD(lvtxIn, itri+1).xyzw,TLOAD(lvtxIn, itri+2).xyzw);
        #define triverts trivertsUnit
        const bbox_t lbox = calcTriBox(triverts);
        const float area = 
            distance(lbox.mn, lbox.mx)*SQRT_OF_ONE_THIRD;
            //0.5f*length(cross((trivertsUnit[1]-trivertsUnit[0]).xyz, (trivertsUnit[2]-trivertsUnit[0]).xyz));
        //const vec4 unorm4f = clamp(fma(vec4((trivertsUnit[0] + trivertsUnit[1] + trivertsUnit[2]).xyz * 0.33333333333333f, fma(area,2.f,-1.f)), 0.5f.xxxx, 0.5f.xxxx),0.f.xxxx,1.f.xxxx);
        const vec4 unorm4f = clamp(vec4((trivertsUnit[0] + trivertsUnit[1] + trivertsUnit[2]).xyz * 0.33333333333333f, fma(area,2.f,-1.f)),-1.f.xxxx,1.f.xxxx);
        const uvec2 mortonCode = encodeMorton(uvec2(packSnorm2x16(unorm4f.xy), packSnorm2x16(unorm4f.zw)));


        {
#ifdef VTX_TRANSPLIT
            const mat4x3 triverts = transpose(triverts);
            imageStore(lvtx, itri+0, vec4(triverts[0].xyz, 1.f)), imageStore(lvtx, itri+1, vec4(triverts[1].xyz, 1.f)), imageStore(lvtx, itri+2, vec4(triverts[2].xyz, 1.f));
#else
            imageStore(lvtx, itri+0, triverts[0]), imageStore(lvtx, itri+1, triverts[1]), imageStore(lvtx, itri+2, triverts[2]);
#endif
        }

#define to globalID

        // store leaf data
        [[flatten]]
        if (globalID < wsize && globalID >= 0) {
            Leafs[to].lbox = lbox, Leafs[to].pdata = ivec4(to.xx, 0, tri+1);
            Mortoncodes[to] = mortonCode;
            MortoncodesIndices[to] = int(to+1);
        }
    }

    LGROUP_BARRIER
}