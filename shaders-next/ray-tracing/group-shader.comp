#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"

// user descriptor set output image
layout ( rgba32f, binding = 2, set = 2 ) uniform image2D ColorOutput;

// use partition by 8x8
//layout (local_size_x = R_BLOCK_WIDTH, local_size_y = R_BLOCK_HEIGHT);
LOCAL_SIZE_LAYOUT;

#define wgs gl_NumWorkGroups.x
//#define wsize rayTypedCounterRead[stageUniform.currentGroup]

#define hitp hitPayload[hitpId]
#define hit hits[hitIdc]

// 
void main() {
    const int wsize = min(rayTypedCounterRead[stageUniform.currentGroup], MAX_RAYS);
    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);
    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        const int globalID = int((w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x);
        //int rayID = rayGroupIndicesRead[globalID*5+(stageUniform.currentGroup+1)]-1;
        const int rayID = rayGroupIndicesRead[globalID]-1;
        bool overflow = globalID >= wsize || globalID < 0 || rayID < 0;

        // get ray by id
        VtRay ray = rays[rayID];//vtFetchRay(rayID);
        const int hitIdc = vtFetchHitIdc(rayID);
        const int hitpId = hits[hitIdc].payloadID-1;
        vec4 emisson = hitp.emission * vec4(1.f - hitp.specularGlossiness.xyz, 1.f);

        // get output image 2D coord
        uvec2 icoord = vtFetchIndex(rayID);
        float alph = (emisson.a > 0.9f || stageUniform.iteration == 1) ? 1.f : 0.f;

        // save result of ray tracing by ray saved indice
        //if (!overflow) { imageStore(ColorOutput, icoord, vec4(f16_f32(ray.dcolor).xyz, 1.f)); }
        
        // add support for multi-passing
        [[flatten]]
        if (!overflow) {
            const vec4 bcolor = imageLoad(ColorOutput, ivec2(icoord));
            imageStore(ColorOutput, ivec2(icoord), vec4(fma(emisson.xyz * alph, f16_f32(ray.dcolor).xyz, bcolor.xyz), 1.f));

            // debug
            //if (stageUniform.iteration == 1) imageStore(ColorOutput, ivec2(icoord), vec4(1.f, 0.f, 1.f, 1.f) * vec4(f16_f32(ray.dcolor).xyz, 1.f));
            //if (stageUniform.iteration == 1) imageStore(ColorOutput, ivec2(icoord), vec4(f16_f32(ray.dcolor).xyz * (fma(dcts(ray.cdirect.xy).xyz, 0.5f.xxx, 0.5f.xxx)), 1.f));

            

            // generate secondary rays (reflections)
            VtRay newray = ray;
            newray.origin.xyz = fma(dcts(newray.cdirect.xy), hit.uvt.zzz, newray.origin.xyz);

            // support of transparency
            [[flatten]]
            if (alph > 0.5f) {
                newray.cdirect.xy = lcts(reflect(dcts(newray.cdirect.xy), hitp.normalHeight.xyz));
                writeColor(newray.dcolor, vec4(f16_f32(newray.dcolor).xyz * hitp.specularGlossiness.xyz, 1.f));
            } else {
                
            }

            // add ray error offset
            if (max3_vec(f16_f32(newray.dcolor)) >= 1e-4f) {
                newray.origin.xyz = fma(dcts(newray.cdirect.xy), 1e-4f.xxx, newray.origin.xyz);
                vtReuseRays(newray, icoord.xy, 0, rayID);
                //vtEmitRays(newray, icoord.xy, 0);
            }
        }
    }

    LGROUP_BARRIER;
}
