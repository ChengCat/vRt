#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"

// user descriptor set output image
layout ( rgba32f, binding = 2, set = 2 ) uniform image2D ColorOutput;

// use partition by 8x8
//layout (local_size_x = R_BLOCK_WIDTH, local_size_y = R_BLOCK_HEIGHT);
LOCAL_SIZE_LAYOUT;

#define wgs gl_NumWorkGroups.x
#define wsize rayTypedCounterRead[stageUniform.currentGroup]

// 
void main() {
    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);
    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = int((w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x);
        int rayID = rayGroupIndicesRead[globalID*4+stageUniform.currentGroup]-1;
        bool overflow = globalID >= wsize || globalID < 0 || rayID < 0;

        // get ray by id
        VtRay ray = vtFetchRay(rayID);
        int hitIdc = vtFetchHitIdc(rayID);
        vec4 emisson = hitPayload[hits[hitIdc].payloadID-1].emission;

        // get output image 2D coord
        uvec2 icoord = vtFetchIndex(rayID);

        // save result of ray tracing by ray saved indice
        //if (!overflow) { imageStore(ColorOutput, icoord, vec4(f16_f32(ray.dcolor).xyz, 1.f)); }
        if (!overflow) { imageStore(ColorOutput, ivec2(icoord), vec4(emisson.xyz, 1.f)); }
    }

    LGROUP_BARRIER;
}
