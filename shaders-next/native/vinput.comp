#version 460 core
#extension GL_GOOGLE_include_directive : enable


#define VERTEX_FILLING
//#define USE_PUSH_CONSTANT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/vertex.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex-input.glsl"

LOCAL_SIZE_LAYOUT;

const int VCOUNT = 3;

#define wsize vertexBlock.primitiveCount

void main() {
    const uint wcount = min(tiled(uint(wsize), gl_WorkGroupSize.x), 1000000u);
    [[unroll, dependency_length(4)]]
    for (uint w=0;w<wcount;w+=gl_NumWorkGroups.x) {
        SB_BARRIER
        const uint globalID = (w + gl_WorkGroupID.x) * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        IFALL (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {
            // constant material ID from vertex instance
            uint rofft = uint(vertexBlock.readOffset) + globalID, wofft = uint(vertexBlock.primitiveOffset) + globalID;

            // read material accessor
            uint matID = 0u;
            readByAccessorIndice(int(vertexBlock.materialAccessor), rofft, matID);
            matID += uint(vertexBlock.materialID);

            // planned to support quad based geometry
            vmaterials[wofft] = int(matID);
            vbitfields[wofft] = vertexBlock.bitfield;

            // load attrib data
            [[unroll]]
            for (uint a=vertexBlock.attributeOffset;a<min(min(ATTRIB_EXTENT, attributes.length()), vertexBlock.attributeCount)+vertexBlock.attributeOffset;a++) {
                [[unroll]]
                for (int i=0;i<3;i++) {
                    vec4 attribValue = vec4(0.f); uint indiceID = rofft * VCOUNT + i;
                    readByAccessorIndice(int(vertexBlock.indiceAccessor), indiceID, indiceID);
                    readByAccessor(attributes[a].accessorID, indiceID, attribValue);
                    storeAttribute(ivec3(wofft, attributes[a].attributeID, i), attribValue);
                }
                storeAttribute(ivec3(wofft, attributes[a].attributeID, 3), 0.f.xxxx);
            }

            // load vertex data
            [[unroll]]
            for (int i=0;i<3;i++) {
                vec4 vertice = vec4(0.f, 0.f, 0.f, 1.f); uint indiceID = rofft * VCOUNT + i;
                readByAccessorIndice(int(vertexBlock.indiceAccessor), indiceID, indiceID);
                readByAccessor(int(vertexBlock.verticeAccessor), indiceID, vertice);
                storePosition(ivec2(wofft, i), vec4(vertice.xyz, 1.f));
            }
            
        }
    }
}
