#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define EXTEND_LOCAL_GROUPS
#define ENABLE_VSTORAGE_DATA
#define BVH_CREATION

#define fpInner 0.f//0.00000011920928955078125f

// force undef fp16
#ifdef USE_F16_BVH
#undef USE_F16_BVH
#endif

// force define fp32
#ifndef USE_F32_BVH
#define USE_F32_BVH
#endif

#include "../../include/driver.glsl"
#include "../../include/mathlib.glsl"
#include "../../include/ballotlib.glsl"
#include "../../include/structs.glsl"
#include "../../include/vertex.glsl"
#include "../submodules/includes.glsl"


layout ( binding = 9, set = 0, std430 )  buffer minmaxB { vec4 minmax[]; };

bbox_t getMinMaxPrimitive(in uint idx) {
    const uint tri = bvhBlock.primitiveOffset+clamp(idx, 0u, max(bvhBlock.primitiveCount,1u)-1u); 
    return Leafs[tri].lbox;
}

bbox_t bbox_tunion(in bbox_t b1, in bbox_t b2) {
    return bbox_t(min(b1.mn, b2.mn), max(b1.mx, b2.mx));
}

bbox_t bbox_tunion3(in bbox_t b1, in bbox_t b2, in bbox_t c3) {
    return bbox_t(min3_wrap(b1.mn, b2.mn, c3.mn), max3_wrap(b1.mx, b2.mx, c3.mx));
}


layout ( local_size_x = WORK_SIZE_BND ) in;
shared bbox_t sdata[ WORK_SIZE_BND ];

void main() {
    IFANY (bvhBlock.primitiveCount <= 0) return;
    const uint tid = gl_LocalInvocationID.x;
    const uint gridSize = (gl_WorkGroupSize.x*2) * gl_NumWorkGroups.x;
    const uint tcount = max( bvhBlock.primitiveCount, 2 );

    // 
    sdata[tid] = bbox_t(INFINITY.xxxx, -INFINITY.xxxx);
    LGROUP_BARRIER

    // calculate boxes for per work
    uint i = gl_WorkGroupID.x * (gl_WorkGroupSize.x*2) + tid;
    while (i < tcount) {
        bbox_t bound = sdata[tid];
        bound = bbox_tunion3(bound, getMinMaxPrimitive(i), getMinMaxPrimitive(i + gl_WorkGroupSize.x));
        sdata[tid] = bound;
        i += gridSize;
    }
    LGROUP_BARRIER

    // shared reduction
    [[unroll]] for (uint ki=(gl_WorkGroupSize.x>>1u);ki>=Wave_Size_RT;ki>>=1) {
        if (tid < ki) { 
            bbox_t bound = sdata[tid], opbound = sdata[tid + ki]; 
            bound = bbox_tunion(bound, opbound);
            sdata[tid] = bound; 
        }
        LGROUP_BARRIER
    }

    { // subgroup min/max
        vec4 mn = subgroupMin(sdata[tid].mn), mx = subgroupMax(sdata[tid].mx);
        sdata[tid].mn = mn, sdata[tid].mx = mx;
    }

    LGROUP_BARRIER

    // store in global memory result of work
     
    if (tid == 0) {
        minmax[gl_WorkGroupID.x*2 + 0] = sdata[tid].mn;
        minmax[gl_WorkGroupID.x*2 + 1] = sdata[tid].mx;
    }

    //LGROUP_BARRIER
}
